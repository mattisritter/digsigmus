\documentclass[12pt, a4paper]{report}
\usepackage[utf8]{inputenc} % Eingabekodierung
\usepackage[T1]{fontenc} % Fontkodierung
\usepackage[english]{babel} % Deutsche Sprache
\usepackage{graphicx} % Grafiken
\usepackage{hyperref} % Hyperlinks
\usepackage{geometry} % Seitenlayout
\usepackage{setspace} % Zeilenabstand
\usepackage{fancyhdr} % Kopf- und Fußzeile
\usepackage{titlesec} % Kapitelnummerierung
\usepackage{adjustbox} % Bildbearbeitung
\usepackage{subcaption}
\usepackage{titletoc}
\usepackage[backend=biber, style=authoryear, maxcitenames=1, mincitenames=1]{biblatex}
\addbibresource{2023_11_29_Seminararbeit.bib}

\geometry{a4paper, margin=2.5cm} % Seitenränder
\hypersetup{colorlinks=true, urlcolor=blue, linkcolor=black, citecolor=black} % Hyperlinks einrichten
\onehalfspacing % Zeilenabstand auf 1,5-fach setzen

\usepackage{enumitem} % Formatierung Aufzählungsverzeichnis enumerate

\makeatletter
\renewcommand{\@roman}[1]{\expandafter\@slowromancap\romannumeral #1@}
\makeatother

\usepackage[printonlyused]{acronym}

\usepackage{glossaries}
\newglossaryentry{symb:A}{
	name={\(A\)},
	description={Beschreibung des Symbols \(A\)}
}
\newglossaryentry{symb:B}{
	name={\(B\)},
	description={Beschreibung des Symbols \(B\)}
}
\makeglossaries

\pagestyle{fancy}
\fancyhf{} % Löscht alle voreingestellten Kopf- und Fußzeileneinstellungen

% Definiere die Kopfzeile
\lhead{\leftmark} % Aktuelles Kapitel auf der linken Seite
\chead{} % Kein Inhalt in der Mitte der Kopfzeile
\rhead{} % Kein Inhalt auf der rechten Seite der Kopfzeile

% Definiere die Fußzeile (optional)
\lfoot{} % Kein Inhalt auf der linken Seite der Fußzeile
\cfoot{\thepage} % Seitenzahl in der Mitte der Fußzeile
\rfoot{} % Kein Inhalt auf der rechten Seite der Fußzeile

\DeclareNameAlias{sortname}{last-first}
\renewcommand*{\nameyeardelim}{\addcomma\addspace}

%Formatierung für Online-Zitate
\DeclareCiteCommand{\citeonline}[\mkbibparens]
{\usebibmacro{prenote}}
{\usebibmacro{citeindex}%
	\printtext[bibhyperref]{%
		\printfield{title}%
		\setunit{\addcomma\space}%
		\printfield{year}}}
{\multicitedelim}
{\usebibmacro{postnote}}

\titleformat{\chapter}[hang]
{\normalfont\huge\bfseries}{\thechapter.}{0.5em}{\huge\bfseries}

\renewcommand{\figurename}{Figure}

\begin{document}

\input{Deckblatt.tex}

\pagenumbering{gobble} % Ausschalten der Seitennummerierung

\renewcommand{\contentsname}{Table of Contents}
\tableofcontents % Inhaltsverzeichnis erstellen
\newpage

\pagenumbering{roman} % Verzeichnisse werden in römischen zahlen nummeriert´

\chapter*{List of Abbreviations}
\label{sec:abkuerzungsverzeichnis}
\begin{acronym}[OpenCV]
	\acro{DFT}{Discrete Fourier Transform}
	\acro{FFT}{Fast Fourier Transform}
\end{acronym}
\newpage

\renewcommand{\listfigurename}{List of Figures}
\listoffigures
\newpage

%\listoftables
%\newpage

%\subsection*{Symbolverzeichnis}
%\label{sec:symbolverzeichnis}
%\printglossary
%\newpage

\pagenumbering{arabic}
\setcounter{page}{1}	% Setze Seitenzähler auf 1

\chapter{Basic Implementations}

\section{\ac{DFT} vs. \ac{FFT}}

\subsection{Implementation Overview}
The \ac{DFT} and \ac{FFT} implementations are provided in \texttt{dft.py} and \texttt{fft.py}, respectively:
\begin{itemize}
	\item \textbf{\ac{DFT}}: Computes the Fourier Transform with \(O(N^2)\) complexity using a direct summation formula.
	\item \textbf{Recursive FFT}: Implements a divide-and-conquer approach, reducing complexity to \(O(N \log N)\).
	\item \textbf{Iterative FFT}: Uses iterative butterfly operations for further optimization, avoiding recursion overhead.
\end{itemize}

\subsection{Verification of Similarities}
The Python script \texttt{test\_dft\_fft.py} validates the numerical equivalence of the \ac{DFT} and \ac{FFT} implementations:
\begin{itemize}
	\item A sinusoidal test signal is processed by all three methods (\ac{DFT}, recursive \ac{FFT}, and iterative \ac{FFT}).
	\item Results are compared element-wise within a tolerance of \(10^{-9}\).
	\item Tests confirm that all implementations produce consistent outputs, differing only by negligible numerical errors.
\end{itemize}
\noindent The visualization script \texttt{vis\_dft\_fft\_simmiliar.py} further illustrates the similarities:
\begin{itemize}
	\item \textbf{Frequency Domain Comparison (Fig. \ref{fig:frequency_domain_comparison} Left)}: All methods accurately identify the signal's frequency components, and only half of the spectrum is shown due to its symmetry for real-valued signals.
	\item \textbf{Time Domain Reconstruction (Fig. \ref{fig:frequency_domain_comparison} Right)}: All methods reconstruct the original signal with minimal deviations.
\end{itemize}

\begin{figure}[h!]
	\centering
	\includegraphics[width=0.45\textwidth]{2023_11_29_Bilder_Dokumentation/Frequency_Domain_Comparison.png}
	\includegraphics[width=0.45\textwidth]{2023_11_29_Bilder_Dokumentation/Time_Domain_Comparison.png}
	\caption{Frequency domain comparison (left) and Time-domain reconstruction validation (right)}
	\label{fig:frequency_domain_comparison}
\end{figure}

\subsection{Comparison of Differences}
To highlight differences, the script \texttt{vis\_dft\_fft\_different.py} visualizes computational time and memory usage for the \ac{DFT} and \ac{FFT}.

\subsubsection{Computational Time and Memory Comparison}
Figure \ref{fig:time_memory_comparison} shows the execution time and memory usage for a fixed signal length:
\begin{itemize}
	\item The \ac{DFT} requires significantly more time due to its \(O(N^2)\) complexity, while both \ac{FFT} implementations achieve \(O(N \log N)\).
	\item The recursive \ac{FFT} is slightly faster than the iterative \ac{FFT}.
	\item Memory usage for the iterative \ac{FFT} is at the lowest, while recursive \ac{FFT} requires the most.
\end{itemize}

\begin{figure}[h!]
	\centering
	\includegraphics[width=0.45\textwidth]{figures/computional_time.pdf}
	\includegraphics[width=0.45\textwidth]{figures/memory_usage.pdf}
	\caption{Computational time for fixed signal length (left). Memory usage comparison (right).}
	\label{fig:time_memory_comparison}
\end{figure}

\subsubsection{Scaling with Signal Length}
Figure \ref{fig:scaling_comparison} examines execution time and memory usage as signal length increases:
\begin{itemize}
	\item Execution time for the \ac{DFT} grows quadratically, while the \ac{FFT} scales logarithmically.
	\item Memory usage for the \ac{DFT} increases linearly, whereas both \ac{FFT} methods maintain near-constant memory requirements.
	\item The recursive \ac{FFT} outperforms the iterative \ac{FFT} for shorter and larger signals.
\end{itemize}

\begin{figure}[h!]
	\centering
	\includegraphics[width=0.45\textwidth]{figures/computional_time_cmp.pdf}
	\includegraphics[width=0.45\textwidth]{figures/memory_usage_cmp.pdf}
	\caption{Execution time vs. signal length (left). Memory usage vs. signal length (right).}
	\label{fig:scaling_comparison}
\end{figure}

\subsection{Conclusion}
The \ac{DFT} and \ac{FFT} produce equivalent results in transforming time-domain signals into the frequency domain. However, the \ac{FFT} offers significant advantages in computational efficiency and memory usage, making it more suitable for large-scale applications. The provided Python scripts and visualizations highlight these differences, offering a practical comparison between the methods.

\section{Modulation and Demodulation (Non- and Quadrature)}

\subsection{Implementation Overview}

Modulation and demodulation are essential processes for signal transformation during transmission and recovery. This implementation includes non-quadrature and quadrature approaches, developed in the Python script \texttt{modulation.py}. The test script \texttt{test\_modula-\newline tion.py} validates functionality, while \texttt{visualize\_modulation.py} provides visual insights into the signal transformations.

\subsection{Purpose and Testing}
The implementation covers:
\begin{itemize}
	\item \textbf{Modulation:} Encoding a signal onto a carrier wave.
	\item \textbf{Demodulation:} Recovering the original signal, verifying expected scaling effects.
	\item \textbf{Quadrature Modulation:} Utilizing orthogonal components (\(f(t)\) and \(g(t)\)) for efficient dual-channel transmission.
\end{itemize}

Tests in \texttt{test\_modulation.py} confirm that:
\begin{itemize}
	\item Modulated signals exhibit the expected transformations.
	\item Demodulated signals accurately reconstruct the originals.
	\item Quadrature modulation and demodulation handle both channels correctly.
\end{itemize}

\subsection{Visualization of Modulation Processes}
Figure \ref{fig:modulation_visualizations} illustrates non-quadrature and quadrature modulation/demodulation.
The left panel shows the original, modulated, and demodulated signals for the non-quadrature case,
where phase shifts and amplitude scaling are evident.
The right panel depicts quadrature modulation and demodulation,
showcasing the successful separation and reconstruction of two orthogonal signal components.
Both visualizations confirm the correctness and reliability of the implementations.

\begin{figure}[h!]
	\centering
	\includegraphics[width=0.9\textwidth]{figures/modulation.pdf}
	\caption{Non-quadrature modulation and demodulation (left). Quadrature modulation and demodulation (right).}
	\label{fig:modulation_visualizations}
\end{figure}

\section{Convolution}

Convolution is implemented in time-domain (\texttt{/module/convolution.py})
and as fast convolution using the \ac{FFT} (\texttt{/module/fast\_convolution.py}).
To verify the correctness of the implementations,
a sawtooth signal is convolved with a shifted impulse signal.
The results are the same for both implementations within a tolerance smaller than \(\pm10^{-15}\).
When convolving with a shifted impulse signal, the convolution is equal to the shifted signal.
This is shown in Figure \ref{fig:convolution}.
\begin{figure}[h!]
	\centering
	\includegraphics[width=0.7\textwidth]{figures/convolution.pdf}
	\caption{Convolution of a sawtooth signal with a shifted impulse signal.}
	\label{fig:convolution}
\end{figure}

\section{Low-Pass Filter}

The filter is implemented in \texttt{/module/low\_pass\_filter.py}.
By convolving the input signal with the filter function of length \(N\),
the signal is low-pass filtered.

\begin{figure}[h!]
	\centering
	\includegraphics[width=0.45\textwidth]{figures/impulse_response.pdf}
	\includegraphics[width=0.45\textwidth]{figures/passband.pdf}
	\caption{Impulse response of the low-pass filter with N=20 (left). Amplitude of the low-passed signal with different filter lengths (right).}
	\label{fig:low_pass_filter}
\end{figure}
As filter function, a \(sinc\) function with applied Hamming windowing is used.
Figure \ref{fig:low_pass_filter} (left) shows the impulse response with and without a Hamming window.
It can be observed that the Hamming window reduces the ripples at the beginning and end of the impulse response.

The frequency response of the low-pass filter is determined by filtering cosine waves with increasing frequencies
and calculating the highest amplitude of the output signal.
This is shown for different filter lengths in Figure \ref{fig:low_pass_filter} (right).
Here, the cut-off frequency is 10 \({rad}/s\).
It can be observed that the steepness of the transition band increases with the filter length.
If no Hamming window is applied, there are ripples in the passband and the stopband.

The performance of the low-pass filter highly depends on the implementation of the convolution.
Table \ref{tab:timing_comparison} shows the timing comparison when using fast convolution and convolution in time-domain.
For the given parameters, the fast convolution is on average more than 2.4 times faster then in time-domain.
\begin{table}[h!]
	\centering
	\begin{tabular}{|l|c|c|}
		\hline
		                   & \textbf{Fast Convolution} & \textbf{Time-Domain Convolution} \\ \hline
		Average time       & 0.2997 \(s\)              & 0.7241 \(s\)                     \\ \hline
		Standard deviation & 0.0397 \(s\)              & 0.0603 \(s\)                     \\ \hline
		Min time           & 0.2598 \(s\)              & 0.6684 \(s\)                     \\ \hline
		Max time           & 0.5171 \(s\)              & 1.269 \(s\)                      \\ \hline
		Median time        & 0.2864 \(s\)              & 0.715 \(s\)                      \\ \hline
	\end{tabular}
	\caption{Timing comparison for Low-Pass Filter using fast convolution and time-domain convolution. Function length = 20000, Filter length = 50, Number of tests = 200.}
	\label{tab:timing_comparison}
\end{table}

\chapter{Overall system}

The overall system recreates the transmission of two signals over a common medium using modulation.
On the sender side, the signals are low-pass filtered, modulated and added.
The sum of both modulated signals is then transmitted to the receiver,
where the signal is demodulated and low-pass filtered again.

\section{Testing with simple signals}

The file \texttt{project.py} contains the implementation of the overall system.
For testing, two simple signals are used.
The first signal is a sum of cosine waves with different frequencies and phases (Equation 2.1)
and the second signal is a sawtooth wave (Equation 2.2).
\begin{equation}
	f_1(t) = 3 + cos(t+1) + 2cos(3t+2) - 5cos(4t-1) + cos(13t)
\end{equation}
\begin{equation}
	f_2(t) = 3 \cdot (t\mod\pi)
\end{equation}
Both signals are sampled 32 times in the interval from 0 to 2\(\pi\).
Each step of the transmission is shown in Figure \ref{fig:overall} (top), where the left side depicts the operations in time-domain
and the right side in frequency-domain, by showing the magnitude of the first half of the Fourier coefficients.
The low-pass filtered signals are compared to the reconstructed signals in the bottom figure.

The cut-off frequency is choosen to be \(\omega_c=\) 7 \(rad/s\).
As seen in the second row, the low-pass filter removes the high frequency components.
Furthermore the sampling rate is increased by factor 2 after the low-pass filter,
because modulation would not be possible without violating the sampling theorem.
Then the signals are modulated with \(\omega_{mod_1}=\) 8 \(rad/s\) and \(\omega_{mod_2}=\) 23 \(rad/s\),
so that their frequency bands do not overlap.
After adding, demodulation and low-pass filtering, the reconstructed signals are nearly equal to the original, low-passed signals.

An alternative approach is to use quadrature modulation.
This is shown in Figure \ref{fig:quadrature},
where the signals are modulated with the same modulation frequency \(\omega_{mod}=\) 8 \(rad/s\),
but with a cosine and a sine wave, respectively.

When a overlap of the frequency bands is introduced,
the signals cannot be reconstructed properly.
For this example the signals are sampled 64 times.
The modulation frequencies are \(\omega_{mod_1}=\) 8 \(rad/s\) and \(\omega_{mod_2}=\) 19 \(rad/s\).
This is shown in Figure \ref{fig:overlap},
where the signals contain noise of the other signal.
Most significant is a noise in the sawtooth signal with a frequency of 7 \(rad/s\).

\section{Testing with sound files}

The overall system is also tested with sound files (\texttt{project\_soundfile.py}).
The first sound file is a Jodler and the second a squeaking violin.
\begin{itemize}
	\item \texttt{soundfiles/Jodler.wav}
	\item \texttt{soundfiles/Violine.wav}
\end{itemize}
The sampling rate is \(f_s=\) 44100 \(Hz\), respectively \(w_s\approx\) 277088 \(rad/s\).
The signals are low-pass filtered with a cut-off frequency \(\omega_c=\) 20000 \(rad/s\).
The modulation frequencies are \(\omega_{mod_1}=\) 25000 \(rad/s\) and \(\omega_{mod_2}=\) 70000 \(rad/s\).
As the signals are well separated in the frequency domain
and the sampling frequency is sufficient,
the reconstruction is successful.
The soundfiles after each operation are saved in the \texttt{soundfiles} directory,
in order to listen to the (intermediate) results.
Figure \ref{fig:soundfiles} depicts the overall system with sound files.

\appendix

\chapter{Figures}

\begin{figure}[h!]
	\centering
	\includegraphics[width=\textwidth]{figures/overall_sampling.pdf}
	\includegraphics[width=0.9\textwidth]{figures/sampling_cmp.pdf}
	\caption{Overall sytsem (top). Reconstructed vs. low-pass filtered signals (bottom).}
	\label{fig:overall}
\end{figure}


\begin{figure}[h!]
	\centering
	\includegraphics[width=\textwidth]{figures/overall_quad.pdf}
	\includegraphics[width=0.9\textwidth]{figures/quad_cmp.pdf}
	\caption{Overall sytsem with quadrature modulation (top). Reconstructed vs. low-pass filtered signals (bottom).}
	\label{fig:quadrature}
\end{figure}

\begin{figure}[h!]
	\centering
	\includegraphics[width=\textwidth]{figures/overall_overlapping.pdf}
	\includegraphics[width=0.9\textwidth]{figures/overlapping_cmp.pdf}
	\caption{Overall sytsem with overlapping frequency bands (top). Reconstructed vs. low-pass filtered signals (bottom).}
	\label{fig:overlap}
\end{figure}

\begin{figure}[h!]
	\centering
	\includegraphics[width=0.9\textwidth]{figures/overall_soundfile.pdf}
	\caption{Overall system with sound files.}
	\label{fig:soundfiles}
\end{figure}

\end{document}
